[{"title":"java基础知识","url":"/2022/02/21/JAVA基础知识/","content":"\n\n# JAVA基础知识\n\n## 容器/集合\n\n### HashMap\n\n![捕获](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/202202151615866.PNG)\n\n聊到HashMap，我需要想到HashMao的那张结构图 最早的HashMap是数组加链表的形式存在的。\n\n（散列）-> 将任意长度的输入转化为固定长度的输出\n\n链表存在着查询差，但插入简单的特点，所以前面几个版本是由segment（桶）这个概念的，不过现在都是在达到临界点后将链表转化为红黑树。（链表长度达到8或者是数组长度大于64时）\n\n基本的几个值\n\n```\n\t/**\n     * The default initial capacity - MUST be a power of two.\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n    /**\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    /**\n     * The load factor used when none specified in constructor.\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n    /**\n     * The bin count threshold for using a tree rather than list for a\n     * bin.  Bins are converted to trees when adding an element to a\n     * bin with at least this many nodes. The value must be greater\n     * than 2 and should be at least 8 to mesh with assumptions in\n     * tree removal about conversion back to plain bins upon\n     * shrinkage.\n     */\n    static final int TREEIFY_THRESHOLD = 8;\n\n    /**\n     * The bin count threshold for untreeifying a (split) bin during a\n     * resize operation. Should be less than TREEIFY_THRESHOLD, and at\n     * most 6 to mesh with shrinkage detection under removal.\n     */\n    static final int UNTREEIFY_THRESHOLD = 6;\n\n    /**\n     * The smallest table capacity for which bins may be treeified.\n     * (Otherwise the table is resized if too many nodes in a bin.)\n     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts\n     * between resizing and treeification thresholds.\n     */\n    static final int MIN_TREEIFY_CAPACITY = 64;\n```\n\n1.DEFAULT_INITIAL_CAPACITY（初始化容量） 1<<4 也就是16\n\n2.MAXIMUM_CAPACITY（最大的容量） = 1 << 30;\n\n3.DEFAULT_LOAD_FACTOR = 0.75f;（负载因子）具体有啥用 源代码中在说，貌似在扩容中有使用到\n\n4.TREEIFY_THRESHOLD（转化为树的临界点） = 8 也就是说在增加数据时，什么时候将list转化为树（也就是之前讲到的链表达到多少长度时会转化为红黑树）\n\n5.UNTREEIFY_THRESHOLD = 6；（这个有点模糊，我看注释的意思是在不是树的时候重新设置容量大小的操作关键 补充：好像是当你移除节点小于6的时候 红黑树要转化为链表）\n\n6.MIN_TREEIFY_CAPACITY = 64 这个就是当数组长度达到64时就会树化。\n\n\n\n好了基本的常量看完了，就是梦开始的地方了！！！\n\n首先既然有链表，那么就会有节点，这里提供了一个静态内部类\n\n```\nstatic class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n```\n\n4个主要的值，计算得到的hash值，key，value以及下一个节点的引用，这就很好地体现了一开始的那个结构\n\n来点有意思的，之前提到过我们是通过散列算法来确定存储的数组下标位置的，这里就是HashMap中的hash计算方式，这个值是先通过hashCode计算出来的值**按位与**他的无符号右移16位来获得\n\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n\n\n然后来点简单的get方法\n\n```\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }//这里会去调用getNode方法,是通过key来进行查找\n    \n    \nfinal Node<K,V> getNode(int hash, Object key) {//这里接收的是hash值和key值\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) { //这里一堆条件同时也进行了一些赋值操作，其中头节点first会通过hash找到 tab[n-1 & hash] \n            if (first.hash == hash && // always check first node  \n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;//这里既然找到了头节点，就好办了，先判断头节点的hash值是否相同，然后是比较key，如果都满足就直接返回\n            if ((e = first.next) != null) {//这里是头节点不满足条件，就接着链表往后找\n                if (first instanceof TreeNode) //这里由于后面会有转化为树的情况，所以在这里要判断是不是树\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);//如果是树就走树的查找方法\n                do {//不是树就开始循环遍历链表\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n}\n```\n\n\n\n上面是获取，接下来就是put方法\n\n```\npublic V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n    \n    //Params:\n\t//hash – hash for key\n\t//key – the key\n\t//value – the value to put\n\t//onlyIfAbsent – if true, don't change existing value\n\t//evict – if false, the table is in creation mode.\n\t//Returns:\n\t//previous value, or null if none\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) { //还是先来看看传入的参数，我们传入的也只有key value\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length; //这里还是简单的判断和赋值 这里resize方法很重要，后面会讲到\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);//这里很显然是看数组位置上是否存在头节点，没有就会建一个，将我们传入的直接丢进去\n        else {//这里就是数组位置上已经有一条链表或者树 这个要判断，然后就可以想象这条链表上或树上是否之前存过相同key，有就覆盖，没有就进行尾插\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;//这里先看头节点是否匹配\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;//记录着集合的修改次数，也就每次add或者remove它的值都会加1\n        if (++size > threshold)//这里我的理解是为了保证容器的查询效率，通过对数组扩容的方式来保证数组中各个链表不至于太长，而影响查询，而这个threshold会在第一个初始化resize时设置 当然后面还有树化来保证查询效率 双管齐下\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n\n\n来吧，重头戏，resize方法：其实这里以及之前都有个迷糊点啊 这个threshold临界点可能不是很清楚干嘛的 因为之前有treeify零界点，导致我容易搞混淆\n\n我在看了一些东西后突然想到了这个值可不可能是因为链表虽然不需要担心扩容之类的问题，但是在查询上是需要遍历是效率不高的，所以说为了使链表不至于太长，所以说我们选择数组扩容，而这个关键就是threshold，因为你每添加一个节点进去就会 size+1 所以说当size > threshold时，为了保证搜索效率而进行的扩容。\n\n```\nif (++size > threshold)\n            resize();\n```\n\n\n\n```\n\n    /**\n     * The next size value at which to resize (capacity * load factor).\n     *\n     * @serial\n     */\n    // (The javadoc description is true upon serialization.\n    // Additionally, if the table array has not been allocated, this\n    // field holds the initial array capacity, or zero signifying\n    // DEFAULT_INITIAL_CAPACITY.)\n    int threshold;//这里说的是重新设置容量后的大小，等下带入下面看看吧.....\n```\n\n\n\n```\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;//首先赋值将需要resize的数组放进来，这里可以看出需要扩容的是数组（一看就知道，啰嗦一句）\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) { //标识不是一个新的HashMap时扩容，就容量和临界值都扩大两倍\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;//这里表示你初始化传入了一个threshold来进行初始化吧，但感觉没啥用\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n            //这里一般就是第一个也就是初始化resize会进入的地方来对cap和thr进行初始化\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);//这个的场景暂时不明确\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n\n\n## 多态\n\n多态是同一个行为具有多个不同表现形式或形态的能力(这个没有同意定义), 关键是分为运行时多态和编译时多态, 运行时多态的体现是在程序运行时确定使用哪一个函数, 比如将子类对象赋值给父类对象, 然后调用某个方法, 而编译时多态是在编译时确定使用哪一个函数, 体现为重载, 在编译时根据参数和返回值类型确定使用哪个函数.","tags":["java"],"categories":["编程"]},{"title":"Linux命令","url":"/2022/02/21/Linux命令/","content":"\n\n\n# Linux命令\n\nuname -r 系统内核版本查看\n\ntar -zxvf 解压命令\n\nwget 下载命令\n\nls -l 查看文件目录 不是1 是L\n\nps -ef|grep redis 查看后台是否启动redis服务\n\nchmod 777 路径/文件 开放读写权限\n\nll 查看当前路径下文件权限\n\ncp 复制备份命令\n\npwd 查看当前路径\n\nlsof -i :端口号 查看端口是否占用\n\nrm -f 文件 删除文件\n\ntouch 文件 创建文件\n\nvim 文件  使用vim文本编辑器\n\nwhereis xxx查看是否有\n\n./文件 表示执行这个文件 例如：./configure\n\ndu -sh 查看当前文件夹大小\n\ndu -h 查看当前文件夹下所有文件 是所有具体的文件"},{"title":"测试一下我的内容","url":"/2022/02/14/hello-world/","content":"---\n\n# 并发\n\n## 特性\n\n原子性\n\n可见性\n\n有序性\n\n## 记录\n\n今天我看到了贴吧中一个贴子，是关于可见性的问题，我看了一下很有意思，自己一开始也不知道为什么\n\n```\npublic class visibilityTest {\n\t//没有加volatile\n    public static Integer flag = 2;\n    public static void main(String[] args) {\n\n        new Thread(()->{\n            System.out.println(\"1号线程启动，执行循环\");\n            while(flag == 2){\n                System.out.println(\"1\");\n            }\n            System.out.println(\"循环结束\");\n        }).start();\n\n        try{\n            Thread.sleep(1000);\n        }catch(InterruptedException e){\n           e.printStackTrace();\n        }\n\n        new Thread(()->{\n            System.out.println(\"二号线程启动\");\n            flag = 3;\n        }).start();\n\n    }\n\n}\n```\n\n以上代码运行你会发现，循环结束了。。。这里问题就在与明明没有保证可见性的东西，为什么线程2修改了变量，线程1很快就获取到了。\n\n这里需要讲到每个线程都有自己的一块工作内存 而实际数据是在主存中，而最后我们会把工作内存的数据更新到主存中。\n\n这里线程2更新数据并保存到了主存，线程1咋知道的。这里一开始我也不清楚，因为一听到可见性就像到volatile，可这也没有啊。\n\n但是通过我的一顿百度，我想我大概是了解了部分真相。\n\n原来 在println中有个操作\n\n```\npublic void println(String x) {\n        synchronized (this) {\n            print(x);\n            newLine();\n        }\n    }\n```\n\n这里会有一个同步代码块，也就是说这里会进行加锁操作\n\n一下是复制的一段\n\nJMM关于synchronized的两条规定：\n\n　　1）线程解锁前，必须把共享变量的最新值刷新到主内存中\n\n　　2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值\n\n　　　（注意：加锁与解锁需要是同一把锁）\n\n   通过以上两点，可以看到synchronized能够实现可见性。同时，由于synchronized具有同步锁，所以它也具有原子性\n\n所以说我们在while循环中使用println时，就是在不断清空工作内存中的共享变量的值，然后获取最新值，所以线程2更新后，线程1能够拿到更新后的值"}]