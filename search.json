[{"title":"JVM调优参数","url":"/2022/03/19/JVM调优参数/","content":"\n# JVM调优参数\n\n引用地址：[JVM参数使用手册 - SegmentFault 思否](https://segmentfault.com/a/1190000010603813)\n\n**Xms**\n英文解释：`Initial heap size(in bytes)`\n中文释义：`堆区初始值`\n使用方法：`-Xms2g` 或 `-XX:InitialHeapSize=2048m`\n\n**Xmx**\n英文解释：`Maximum heap size(in bytes)`\n中文释义：`堆区最大值`\n使用方法：`-Xmx2g` 或 `-XX:MaxHeapSize=2048m`\n\n**Xmn**\n英文解释：`Maximum new generation size(in bytes)`\n中文释义：`新生代最大值`\n使用方法：`-Xmn512m` 或 `-XX:MaxNewSize=512m`\n\n**PermSize**(JDK1.8以后已废弃)\n英文解释：`Initial size of permanent generation(in bytes)`\n中文释义：`永久代初始大小`\n使用方法：`-XX:PermSize=128m`\n\n**MaxPermSize**(JDK1.8以后已废弃)\n英文解释：`Maximum size of permanent generation(in bytes)`\n中文释义：`永久代最大值`\n使用方法：`-XX:MaxPermSize=256m`\n\n**MetaspaceSize**(JDK1.8以后用于替换PermSize)\n英文解释：`Initial size of Metaspaces (in bytes)`\n中文释义：`元数据区初始大小`\n使用方法：`-XX:MetaspaceSize=128m`\n\n**MaxMetaspaceSize**(JDK1.8以后用于替换MaxPermSize)\n英文解释：`Maximum size of Metaspaces (in bytes)`\n中文释义：`元数据区最大值`\n使用方法：`-XX:MaxMetaspaceSize=256m`\n\n**Xss**\n英文解释：`Thread Stack Size(in Kbytes)`\n中文释义：`线程栈最大值`\n使用方法：`-Xss256k` 或 `-XX:ThreadStackSize=256k`\n\n**MaxDirectMemorySize**\n英文解释：`Maximum total size of NIO direct-buffer allocations`\n中文释义：`最大直接内存（堆外）大小`\n使用方法：`-XX:MaxDirectMemorySize=256m`\n\n\n\n## GC策略相关\n\n> 通过这些参数可以对JVM的GC性能进行调优\n\n**NewRatio**\n英文解释：`Ratio of old/new generation sizes`\n中文释义：`老年代和新生代的比值`\n使用方法：`-XX:NewRatio=2`\n使用经验：假如设为2，则表示老年代最大内存占堆最大内存的2/3，新生代则为1/3。如果设置了Xmn或者NewSize/MaxNewSize，那么NewRatio配置无效\n\n**SurvivorRatio**\n英文解释：`Rato of eden/survivor space size`\n中文释义：`新生代中eden区和survivor区的比值`\n使用方法：`-XX:SurvivorRatio=6`\n使用经验：假如设为6，则表示每个survivor区跟eden区的比值为1:6,每个survivor区占新生代的八分之一\n\n**PretenureSizeThreshold**\n英文解释：`Maximum size in bytes of objects allocated in DefNew generation;zero means no maximum`\n中文释义：`可以在新生代直接分配的对象最大值，0表示没有最大值`\n使用方法：`-XX:PretenureSizeThreshold=1000000`\n使用经验：设置该参数，可以使大于这个值的对象直接在老年代分配，避免在Eden区和Survivor区发生大量的内存复制，该参数只对Serial和ParNew收集器有效，Parallel Scavenge并不认识该参数\n\n**MaxTenuringThreshold**\n英文解释：`Maximum value fo tenuring threshold`\n中文释义：`年轻代最大年龄`\n使用方法：`-XX:MaxTenuringThreshold=10`\n使用经验：每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代，最大支持15\n\n**UseSerialGC**\n英文解释：`Use the Serial garbage collector`\n中文释义：`年轻代使用Serial垃圾收集器`\n使用方法：\n开启 `-XX:+UseSerialGC`\n使用经验：不推荐使用，性能太差，老年代将会使用SerialOld垃圾收集器\n\n**UseParNewGC**\n英文解释：`Use parallel threads in the new generation`\n中文释义：`年轻代使用ParNew垃圾收集器`\n使用方法：\n开启 `-XX:+UseParNewGC`\n\n**ParallelGCThreads**\n英文解释：`Number of parallel threads parallel gc will use`\n中文释义：`并行执行gc的线程数`\n使用方法：`-XX:ParallelGCThreads=16`\n\n**UseParallelGC**\n英文解释：`Use the Parallel Scavenge garbage collector`\n中文释义：`年轻代使用Parallel Scavenge垃圾收集器`\n使用方法：\n开启 `-XX:+UseParallelGC`\n使用经验：Linux下1.6,1.7,1.8默认开启，老年代将会使用SerialOld垃圾收集器\n\n**UseParallelOldGC**\n英文解释：`Use the Parallel Old garbage collector`\n中文释义：`年轻代使用Parallel Scavenge收集器`\n使用方法：\n开启 `-XX:+UseParallelOldGC`\n使用经验：老年代将会使用Parallel Old收集器\n\n**UseConcMarkSweepGC**\n英文解释：`Use Concurrent Mark-Sweep GC in the old generation`\n中文释义：`老年代使用CMS收集器（如果出现\"Concurrent Mode Failure\"，会使用SerialOld收集器）`\n使用方法：\n开启 `-XX:+UseConcMarkSweepGC`\n使用经验：年轻代将会使用ParNew收集器\n\n**CMSInitiatingOccupancyFraction**\n英文解释：`Percentage CMS generation occupancy to start a CMS collection cycle. A negative value means that CMSTriggerRatio is used`\n中文释义：`触发执行CMS回收的当前年代区内存占用的百分比，负值表示使用CMSTriggerRatio设置的值`\n使用方法：`-XX:CMSInitiatingOccupancyFraction=75`\n使用经验：该参数需配合UseCMSInitiatingOccupancyOnly一起使用\n\n**UseCMSInitiatingOccupancyOnly**\n英文解释：`Only use occupancy as a criterion for staring a CMS collection`\n中文释义：`只根据占用情况作为开始执行CMS收集的标准，默认关闭`\n使用方法：\n开启 `-XX:+UseCMSInitiatingOccupancyOnly`\n\n**UseCMSCompactAtFullCollection**\n英文解释：`Use Mark-Sweep-Compact algorithm at full collections`\n中文释义：`使用CMS执行Full GC时对内存进行压缩，默认关闭`\n使用方法：\n开启 `-XX:+UseCMSCompactAtFullCollection`\n\n**CMSFullGCsBeforeCompaction**\n英文解释：`Number of CMS full collection done before compaction if > 0`\n中文释义：`多少次FGC后进行内存压缩`\n使用方法：`-XX:CMSFullGCsBeforeCompaction=1`\n\n**CMSClassUnloadingEnabled**\n英文解释：`Whether class unloading enabled when using CMS GC`\n中文释义：`当使用CMS GC时是否启用类卸载功能，默认关闭`\n使用方法：\n开启 `-XX:+CMSClassUnloadingEnabled`\n\n**CMSParallelRemarkEnabled**\n英文解释：`Whether parallel remark enabled (only if ParNewGC)`\n中文释义：`是否启用并行标记（仅限于ParNewGC），默认关闭`\n使用方法：\n开启 `-XX:+CMSParallelRemarkEnabled`\n\n**UseG1GC**\n英文解释：`Use the Garbage-First garbage collector`\n中文释义：`使用G1垃圾收集器`\n使用方法：\n开启 `-XX:+UseG1GC`\n\n**MaxGCPauseMillis**\n英文解释：`Adaptive size policy maximum GC pause time goal in millisecond, or (G1 Only) the maximum GC time per MMU time slice`\n中文释义：`自适应大小策略的最大GC暂停时间目标（以毫秒为单位），或（仅G1）每个MMU时间片的最大GC时间`\n使用方法：`-XX:MaxGCPauseMillis=200`\n\n**DisableExplicitGC**\n英文解释：`Ignore calls to System.gc()`\n中文释义：`禁用System.gc()触发FullGC`\n使用方法：\n开启 `-XX:+DisableExplicitGC`\nPS:不建议开启，如果开启了这个参数可能会导致堆外内存无法及时回收造成内存溢出\n\n## GC日志相关\n\n> 通过这些参数可以对JVM的GC日志输出进行配置，方便分析\n\n**Xloggc**\n英文解释：`GC log file`\n中文释义：`GC日志文件路径`\n使用方法：`-Xloggc:/data/gclog/gc.log`\n\n**UseGCLogFileRotation**\n英文解释：`Rotate gclog files(for long running applications). It requires -Xloggc:<filename>`\n中文释义：`滚动GC日志文件，须配置Xloggc`\n使用方法：\n开启 `-XX:+UseGCLogFileRotation`\n\n**NumberOfGCLogFiles**\n英文解释：`Number of gclog files in rotation(default:0,no rotation)`\n中文释义：`滚动GC日志文件数，默认0，不滚动`\n使用方法：`-XX:NumberOfGCLogFiles=4`\n\n**GCLogFileSize**\n英文解释：`GC log file size,requires UseGCLogFileRotation. Set to 0 to only trigger rotation via jcmd`\n中文释义：`GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发`\n使用方法：`-XX:GCLogFileSize=100k`\n\n**PrintGCDetails**\n英文解释：`Print more details at garbage collection`\n中文释义：`GC时打印更多详细信息，默认关闭`\n使用方法：\n开启 `-XX:+PrintGCDetails`\n可以通过`jinfo -flag [+|-]PrintGCDetails <pid>` 或 `jinfo -flag PrintGCDetails=<value> <pid>` 来动态开启或设置值\n\n**PrintGCDateStamps**\n英文解释：`Print date stamps at garbage collection`\n中文释义：`GC时打印时间戳信息，默认关闭`\n使用方法：\n开启 `-XX:+PrintGCDateStamps`\n可以通过`jinfo -flag [+|-]PrintGCDateStamps <pid>` 或 `jinfo -flag PrintGCDateStamps=<value> <pid>` 来动态开启或设置值\n\n**PrintTenuringDistribution**\n英文解释：`Print tenuring age information`\n中文释义：`打印存活实例年龄信息，默认关闭`\n使用方法：\n开启 `-XX:+PrintTenuringDistribution`\n\n**PrintGCApplicationStoppedTime**\n英文解释：`Print the time of application has been stopped`\n中文释义：`打印应用暂停时间，默认关闭`\n使用方法：\n开启 `-XX:+PrintGCApplicationStoppedTime`\n\n**PrintHeapAtGC**\n英文解释：`Print heap layout before and after each GC`\n中文释义：`GC前后打印堆区使用信息，默认关闭`\n使用方法：\n开启 `-XX:+PrintHeapAtGC`","tags":["JVM"],"categories":["运维"]},{"title":"Docker学习","url":"/2022/03/16/Docker学习/","content":"\n# Docker学习\n\n[TOC]\n\n思想来源于集装箱\n\n镜像、隔离\n\n容器化技术 ->节省资源\n\n用于解决不同电脑上可能会无法运行项目的问题，你可能会发现在你电脑上能够运行的项目，放在其他电脑上就可能会无法运行。就算能运行也会让你去配置环境很麻烦。为了解决这个麻烦，大佬们想到了，我把项目和环境一起打包发到其他电脑，让他带着自身的环境跑。例如：以前只需要发送jar包或war包，而现在你需要发送的是 jar+mysql+redis+ES的集合体 相当于另一台电脑不用配置拿来直接运行也能成功。同时这种还是隔离的 也就是说存在多个，都在自己的环境上运行\n\n这里涉及到了虚拟化技术以及容器化技术 传统虚拟机 和 docker 一个是虚拟出整个计算机 而另一个则是虚拟出核心应用\n\n![image-20210615101211422](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210615101211422.png)\n\n\n\n![image-20210615101337685](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210615101337685.png)\n\n## 在服务器上安装docker\n\n### 1.卸载旧的版本  \n\n```\nyum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n\n### 2.需要的安装包\n\n```\nyum install -y yum-utils\n```\n\n### 3.设置镜像的仓库 默认是国外的\n\n```\nyum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n```\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n```\n\n### **4.**更新yum软件包索引 \n\n```\nyum makecache fast\n```\n\n### 5.安装doker相关的簇 docker-ce 社区 ee企业版\n\n```\nyum install docker-ce docker-ce-cli containerd.io\n```\n\n### 6.启动docker\n\n```\nsystemctl start docker\n```\n\n### 7.测试hello-word镜像\n\n```\ndocker run hello-world\n```\n\n### 8.卸载docker环境\n\nUninstall Docker Engine\n\n1. Uninstall the Docker Engine, CLI, and Containerd packages:\n\n   ```\n   $ sudo yum remove docker-ce docker-ce-cli containerd.io\n   ```\n\n2. Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:\n\n   ```\n   $ sudo rm -rf /var/lib/docker\n   $ sudo rm -rf /var/lib/containerd\n   ```\n\nYou must delete any edited configuration files manually.\n\n\n\n## docker命令\n\n列出本地镜像docker images\n\n进入rabbitmq容器docker exec -it 容器名 /bin/bash\n\n退出容器exit\n\n查看运行的容器 docker ps\n\n重启容器 docker restart 容器ID\n\n```\n//在PowerShell中\ndocker inspect --format='{{.Name}} - {{range .[NetworkSettings.Networks](http://networksettings.networks/)}}{{.IPAddress}}{{end}}' $(docker ps -aq)\n```\n\n\n\n### **Docker常用命令**1\n\n容器停止：docker stop \n\n容器名称启动容器：docker start \n\n容器名称删除容器：docker rm \n\n容器名称删除镜像：docker rmi \n\n镜像名称查看运行的所有容器：docker ps\n\n查看所有容器：docker ps -a\n\n容器复制文件到物理机：docker cp 容器名称:容器目录 物理机目录\n\n物理机复制文件到容器：docker cp 物理机目录 容器名称:容器目录\n\n### 帮助命令\n\ndocker version #显示版本信息\n\ndocker info #显示docker的系统信息，包括镜像和容器的数量\n\ndocker 命令 --help #万能帮助命令\n\n#### 帮助文档地址\n\n[Reference documentation | Docker Documentation](https://docs.docker.com/reference/)\n\n### 镜像命令\n\n##### docker images 查看所有本地的主机上的镜像\n\n```\ndocker images #查看所有镜像\ndocker images -a #列出所有镜像\ndocker images -q #只列出镜像id\n```\n\n##### docker search 搜索镜像\n\ndocker search\n\n```\n# docker search --help \n\nUsage:  docker search [OPTIONS] TERM\n\nSearch the Docker Hub for images\n#这里发现可以通过过滤条件来进行搜索镜像\nOptions:\n  -f, --filter filter   Filter output based on conditions provided\n      --format string   Pretty-print search using a Go template\n      --limit int       Max number of search results (default 25)\n      --no-trunc        Don't truncate output\n\ndocker search mysql --filter=STARS=3000\n```\n\n##### docker pull 下载/拉去镜像\n\n```\n#下载镜像 docker pull 镜像名[:tag]\n#例如 docker pull mysql:5.7\n# docker pull mysql\nUsing default tag: latest #不写tag 默认latest 最新\n\nlatest: Pulling from library/mysql\n69692152171a: Pull complete #分层下载，docker image的核心 联合文件系统\n1651b0be3df3: Pull complete \n951da7386bc8: Pull complete \n0f86c95aa242: Pull complete \n37ba2d8bd4fe: Pull complete \n6d278bb05e94: Pull complete \n497efbd93a3e: Pull complete \nf7fddf10c2c2: Pull complete \n16415d159dfb: Pull complete \n0e530ffc6b73: Pull complete \nb0a4a1a77178: Pull complete \ncd90f92aa9ef: Pull complete \nDigest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969 #签名\nStatus: Downloaded newer image for mysql:latest\ndocker.io/library/mysql:latest #真实地址\n\n```\n\n##### docker rmi 删除镜像\n\n```\ndocker rmi -f 容器id #删除指定的镜像\ndocker rmi -f 容器id 容器id 容器id #删除多个镜像\ndocker rmi -f $(docker images -aq) #一次性删除所有镜像\n```\n\n\n\n### 容器命令\n\n说明：有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习\n\n```\ndocker pull centos\n```\n\n##### 新建容器并启动\n\n```\ndocker run [可选参数] image\n\n#可选参数说明\n--name=\"Name\"  容器名字 区分容器\n-d\t\t\t\t后台方式运行\n-it\t\t\t使用交互方式运行，进入容器查看内容\n-p\t\t\t\t指定容器的端口 -p 8080\n\t\t-p ip:主机端口：容器端口\n\t\t-p 主机端口：容器端口（常用）\n\t\t-p 容器端口\n\t\t容器端口\n-P\t\t\t\t随机指定端口\n\n#测试，启动并进入容器\ndocker run -it centos /bin/bash\n\n#从容器退出回主机\nexit\n```\n\n##### 列出所有运行中的容器\n\n```\ndocker ps #列出当前正在运行的容器\ndocker ps -a #列出当前正在运行的容器，带出历史运行过的容器\n-n=? #显示最近创建的容器\n-q #只显示容器的编号\n```\n\n##### 退出容器\n\n```\nexit #退出并停止\nCtrl + P + Q #容器不停止退出\n```\n\n##### 删除容器\n\n```\ndocker rm 容器id #删除指定容器 无法删除 正在运行的删除\n-f 强制删除\ndocker rm -f $(docker ps -aq) #删除所有正在运行的容器\ndocker ps -a -q|xargs docker rm #删除所有容器\n```\n\n##### 启动和停止容器的操作\n\n```\ndocker start 容器id\ndocker restart 容器id\ndocker stop 容器id\ndocker kill 容器id\n```\n\n\n\n##### 开机自启动容器\n\n```\ndocker update xxxx --restart=always\n```\n\n\n\n### 常用的其他命令\n\n#### 后台启动容器\n\n```\ndocker run -d centos\n#问题发现docker ps 发现centos停止 没有启动啊\n#常见的坑 docker 容器启动后台运行 就必须要有一个前台进程，如果docker没有发现前台 就会自动停止\n#nginx 容器启动后 发现自己没有提供服务 就会立刻停止 就没有程序了\n```\n\n#### 查看日志\n\n```\ndocker logs -f -t --tail 数量 容器id\n#-f -t 可以合并成 -tf\ndocker logs -tf --tail 数量 容器id\ndocker logs -tf --tail 10 e57567db3d69\n#退出日志查看\nctrl + c\n```\n\n#### 查看容器中进程的信息\n\n```\ndocker top 容器id\n```\n\n#### 查看镜像元数据\n\n```\ndocker image inspect 镜像名\n```\n\n```\ndocker inspect 容器id\n```\n\n![image-20210615131322464](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210615131322464.png)\n\n#### 进入当前正在运行的容器\n\n```\n#我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置\ndocker exec -it 容器id /bin/bash\n\ndocker attach 容器id \n#docker exec 进入容器后开启一个新的终端 然后进行操作\n#docker attach 进入容器正在执行的终端\n```\n\n#### 从容器内拷贝文件到主机上\n\n```\ndocker cp 容器id:容器内路径 目的的主机路径\n```\n\n\n\n## 底层原理\n\n![image-20210614161706676](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210614161706676.png)\n\n![image-20210614161807275](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210614161807275.png)\n\n![image-20210614161909705](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210614161909705.png)\n\n\n\n## 小练习\n\n### 1.安装nginx\n\n```\n1.docker search nginx #先查找镜像（这种一般都有官方镜像）\n\n2.docker pull nginx #拉取镜像\n\n3.docker run -d --name nginx01 -p 3304:80 nginx #运行 \n```\n\n这里 -p命令要多讲一句 3304 和 80 因为docker中是容器与容器之间隔离 而每个容器相当于一个小的liunx环境 而我们是在linux上使用docker里面的容器 而3304 80 就相当于映射关系 ，容器暴露出来的是80 而外面的linux暴露给用户的是3304 访问3304 就相当于访问这个容器的80端口\n\n![image-20210621093031956](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621093031956.png)\n\n\n\n### 2.安装Tomcat\n\n```\n1.docker search tomcat #先查找tomcat镜像\n\n2.docker pull tomcat #拉取tomcat 最新镜像 可以指定版本号\n\n3.docker run -d --name tomcat01 -p 3305:8080 tomcat #启动tomcat\n```\n\n这里你会发现虽然启动 但是访问 3305 却是404 因为这里下载的镜像中 tomcat是阉割版的 webapps里面没有任何东西 此时我们就需要进入容器 将webapps.dist中的东西复制到webapps中就有界面了\n\n```\ncp -r webapps.dist/* webapps\n```\n\n\n\n### 3.安装ElasticSearch\n\n```\n1.docker search elasticsearch #先查找es\n\n2.docker pull elasticsearch #拉去es\n\n3.docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx 512m\" elasticsearch:tag\n#这里启动es 但是你会发现占用很多 这里可以给参数设置占用\n\n```\n\n\n\n\n\n## 可视化\n\nportainer(先用这个)\n\n```\ndocker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce\n```\n\nRancher(CI/CD再用)\n\n\n\n什么是portainer？\n\nDocker图形化界面管理工具！提供一个后台供我们操作\n\n```\ndocker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce\n```\n\n![image-20210621101624416](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621101624416.png)\n\n![image-20210621101706750](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621101706750.png)\n\n![image-20210621101745842](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621101745842.png)\n\n平时不会用 玩玩即可\n\n\n\n## Docker镜像讲解\n\n### 镜像是什么\n\n镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件\n\n如何获取镜像：\n1.远程仓库下载\n\n2.朋友拷贝\n\n3.自己制作 DockerFile\n\n### Docker镜像加载原理\n\nUnionFS(联合文件系统)\n\n我们下载的时候看到的一层一层的就是这个！\n\n![image-20210621103719585](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621103719585.png)\n\n![image-20210621103804494](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621103804494.png)\n\n### 分层理解\n\n分层的镜像\n\n当我们去下载一个镜像，注意观察下载的日志输出， 可以看到时一层一层的在下载\n\n![image-20210621104148017](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621104148017.png)\n\n\n\n![image-20210621105014067](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621105014067.png)\n\n![image-20210621105041126](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621105041126.png)\n\n![image-20210621105104213](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621105104213.png)\n\n![image-20210621104942787](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621104942787.png)\n\n\n\n![image-20210621104727300](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621104727300.png)\n\n![image-20210621104903011](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621104903011.png)\n\n如何提交自己的镜像\n\n### Commit镜像\n\ndocker commit\n\n```\nUsage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n\nCreate a new image from a container's changes\n\nOptions:\n  -a, --author string    Author (e.g., \"John Hannibal Smith <hannibal@a-team.com>\")\n  -c, --change list      Apply Dockerfile instruction to the created image\n  -m, --message string   Commit message\n  -p, --pause            Pause container during commit (default true)\n\n\ndocker commit -m=\"描述\" -a=\"作者\" 容器id/镜像名 标签tag\n```\n\n实战测试：\n\n拿tomcat为例，之前讲过由于是阉割版，所以webapps下没有文件，而我将webapps.dist下的文件拷贝过去了，这就是一个操作，相当于在之前的基础上加了一层\n\n![image-20210621111324594](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621111324594.png)\n\n然后就可以提交\n\n```\ndocker commit -m=\"add webapps app\" -a=\"wangchengyang\" 246c13894f24 tomcat02\n```\n\n![image-20210621111520668](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210621111520668.png)\n\n\n\n## 容器数据卷\n\n### 什么是容器数据卷？\n\ndocker的概念\n\n将应用和环境打包成一个镜像\n\n如果有许多数据都在容器中，删除容器后，数据就会丢失。例如：mysql容器中保存sql数据 删了的话就会丢失------>此时我们需要数据可以持久化（持久化安装docker的本地/虚拟机上）\n\ndocker容器间也需要有一个数据同步的技术 docker产生的数据同步到本地！\n\n卷技术 目录的挂载 将容器中的目录 挂载到linux下\n\n![image-20210622091901509](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622091901509.png)\n\n小结：容器数据的持久化和同步，以及容器间数据的共享（例如：多个mysql容器，设置同一个持久化目录 到时候读取都是在同一个目录下的文件读取，从而实现数据共享）\n\n### 使用数据卷\n\n方式一：1.使用命令来挂载\n\n```\ndocker run -it -v 主机目录：容器目录 镜像名 /bin/bash #启动设置卷并进入\ndocker run -it -v /home/ceshi:/home centos /bin/bash\n```\n\n使用 docker inspect 容器id 查看容器具体信息 发现有个挂载\n\n![image-20210622093028857](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622093028857.png)\n\n有双向绑定那味了\n\n![image-20210622093550889](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622093550889.png)\n\n\n\n再来测试：\n\n1.停止容器\n\n2.在主机上修改文件\n\n3。重启容器\n\n4.容器内的数据依旧是同步的\n\n![image-20210622094541989](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622094541989.png)\n\n这里看出 主机的修改也能应用到容器中，这是一个双向绑定\n\n\n\n\n\n### 实战：安装MySQL\n\nMySQL的数据持久化的问题！\n\n```\ndocker search mysql\ndocker pull mysql\n#官方启动\ndocker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\n\n我们自己启动\n-d 后台运行\n-p 端口映射\n-v 数据卷挂载\n-e 环境参数配置\ndocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql\n```\n\n然后通过数据库可视化工具 添加数据库 test 这里就可以看出新增了test\n\n![image-20210622101847631](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622101847631.png)\n\n\n\n### 具名挂载和匿名挂载\n\n```\n#匿名挂载\n-v 容器内路径\n-P 容器自己指定端口映射 大p和小p的区别\ndocker run -d -P -v /etc/nginx --name nginx01 nginx\n\n#查看所有的volume（卷）的情况\ndocker volume ls\n\n#具名挂载\ndocker run -d -P -v juming-nginx:/etc/nginx --name nginx02 nginx\n```\n\n![image-20210622103055810](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622103055810.png)\n\n```\n#查看卷的具体信息\ndocker volume inspect 卷名\ndocker volume inspect juming-nginx\n```\n\n![image-20210622103253209](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622103253209.png)\n\n所有没有指定目录的卷 都是在 /var/lib/docker/volumes/xxxxx/_data\n\n```\n-v 容器内路径  #匿名挂载\n-v 卷名:容器内路径 \n-v 主机路径:容器内路径 #指定路径挂载\n```\n\n拓展：\n\n```\n#通过 -v 容器内路径:ro rw 改变读写权限\nro readonly #只读\nrw readwrite #可读可写\n\ndocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx\ndocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx\n```\n\n### 初识DockerFile\n\n用于创建镜像 这里通过创建镜像的同时挂载卷 这里是通过写脚本来创建镜像所以卷的挂载也在这个脚本中！\n\nDockerFile就是用来构建docker镜像的构建文件！命令脚本\n\n通过脚本可以生成一个镜像，镜像是一层一层的，所以脚本是一个一个的命令\n\n![image-20210622113506479](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622113506479.png)\n\n```\n#生成镜像 （切记 最后有个 .）\ndocker build -f /home/docker-test-volume/dockerfile1 -t wangchengyang/centos:1.0 . \n```\n\n然后通过进项启动容器(这里我是以centos为基础 搭建的镜像)\n\n```\ndocker run -it 镜像名 /bin/bash\nls -l查看目录 你会发现有volume1 和 volume2这两个文件\n```\n\n![image-20210622114037299](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622114037299.png)\n\n接下来我们去在volume1中创建个文件 container.txt\n\n退出容器并查看容器详细信息 （去看挂载卷目录）\n\n![image-20210622114228368](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622114228368.png)\n\n和明显没指定主机路径 就会在/var/lib/docker/volumes 下面 去看一下是否有container.txt\n\n![image-20210622114434462](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622114434462.png)\n\n总结：这种方法就是在构建镜像的时候就挂载数据卷 当然这里是一个匿名卷\n\n而我们也可以手动通过 -v 来挂载\n\n### 数据卷容器\n\n![image-20210622114733997](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210622114733997.png)\n\n```\n--volumes-from\n```\n\n其实这里老师讲的有问题 这里我们使用的是刚才自己的镜像 而这个镜像都是挂载到了本地也就是所以就算创建三个容器但这个三个容器挂载的数据卷本机上的路径都是一样的，而这样看来就已经实现了数据共享（因为双向绑定） 而这个--volumes-from则更多地类似于指出关系；也许就正常的而言，在都没挂载卷的情况下使用这个命令会是单纯容器之间的数据共享\n\n## DockerFile\n\n先来看看什么是DockerFile，其实这是构建镜像的脚本文件\n\n构建步骤：\n\n​\t1.编写一个DockerFile文件\n\n​\t2.docker build 构建镜像\n\n​\t3.docker run 运行镜像\n\n​\t4.docker push 发布镜像（DockerHub、阿里云）\n\n### DockerFile构建过程\n\n基础知识：\n\n​\t1.每个保留关键字（指令）都是必须是大写字母\n\n​\t2.执行从上到下顺序执行\n\n​\t3.#表示注解\n\n​\t4.每一个指令都会创建提交一个新的镜像层，并提交\n\n![image-20210624112411623](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624112411623.png)\n\n\n\n### DockerFile指令\n\nFROM\t\t\t基础镜像 一切从这里开始\n\nMAINTAINER\t\t\t镜像是谁些的，姓名+邮箱 wangchengyang<2837288678@qq.com>\n\nRUN\t\t\t\t镜像构建时需要执行的命令\n\nADD\t\t\t\t添加内容 比如说我基础是centos要加一个tomcat\n\nWORKDIR\t\t镜像工作目录\n\nVOLUME\t\t\t卷 挂载的目录\n\nEXPOSE\t\t\t暴露端口\n\nCMD\t\t\t\t\t指定容器启动时候要运行的命令 命令会覆盖 如本来CMD ls\n\nENTRYPOINT\t\t指定这个容器启动的时候要运行的命令 可以追加命令\n\nONBUILD\t\t\t当构建一个被继承DockerFile 这个时候就会触发ONBUILD指令，该配置指定当所创建的镜像作为其他新建镜像的基础镜像时所执行的指令。\n\nCOPY\t\t\t\t\t类似ADD 将文件拷贝到镜像中\n\nENV                      构建时候的环境配置（例如环境变量的配置）\n\n### 实战\n\n#### 构建自己的centos\n\n先编写DockerFile\n\n![image-20210624113644384](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624113644384.png)\n\n然后通过\n\ndocker build -f mydockerfile-centos -t mycentos:1.0 .\n\n来构建自己的镜像\n\n最后启动 你会发现安装了vim和net-tools 可以使用vim和ifconfig命令了\n\n\n\ndocker history 镜像id 可以查看镜像是如何安装\n\n![image-20210624114020576](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624114020576.png)\n\n\n\n#### 构建tomcat\n\n1.准备镜像文件 tomcat压缩包 jdk的压缩包\n\n![image-20210624114950718](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624114950718.png)\n\n2.编写dockerfile文件 官方命名Dockerfile build会自动寻找这个文件，就不需要-f指定\n\n![image-20210624125642278](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624125642278.png)\n\n```\nFROM centos\nMAINTAINER wangchengyang<2837288678@qq.com>\n\nCOPY readme.txt /usr/local/readme.txt\n\nADD jdk-8u291-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-9.0.48.tar.gz /usr/local/\n\nRUN yum -y install vim\n\nENV MYPATH /usr/local\nWORKDIR /usr/local\n\n\nENV JAVA_HOME /usr/local/jdk1.8.0_291\nENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.48\nENV CATALINA_BASH /usr/local/apache-tomcat-9.0.48\nENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\n\nEXPOSE 8080\n\nCMD /usr/local/apache-tomcat-9.0.48/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.48/bin/logs/catalina.out\n\n```\n\n3.构建镜像\n\n![image-20210624125613776](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624125613776.png)\n\n![image-20210624125709347](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624125709347.png)\n\n4.启动镜像\n\n```\ndocker run -d -p 9090:8080 --name wangchengyangtomcat -v /tomcat/test:/usr/local/apache-tomcat-9.0.48/webapps/test -v /tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.48/logs diytomcat\n```\n\n5.访问测试\n\ncurl localhost:9090\n\n\n\n6.发布项目（由于做了卷挂载，我们直接在本地编写项目就可以发布）\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\n                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\"\n         metadata-complete=\"true\">\n</web-app>\n```\n\n```\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<body>\n<h2>Hello World!</h2>\n \n</body>\n</html>\n```\n\n这里遇到一个坑 我将index.jsp放入了test/WEB-INF下 但因为只是个简单配置WEB-INF下只放web.xml就够了 index.jsp 应该和WEB-INF同级\n\n\n\n### 发布自己的镜像\n\nDockerHub\n\n1.地址[Docker Hub](https://hub.docker.com/) 要有自己的账号\n\n2.确定账号可以登录\n\n3.在服务器上提交自己的镜像\n\n现在服务器上登录docker\n\n```\n[root@izuf66wqqqhhr0ktipcmxfz test]# docker login --help\n\nUsage:  docker login [OPTIONS] [SERVER]\n\nLog in to a Docker registry.\nIf no server is specified, the default is defined by the daemon.\n\nOptions:\n  -p, --password string   Password\n      --password-stdin    Take the password from stdin\n  -u, --username string   Username\n\n```\n\n![image-20210624143302197](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624143302197.png)\n\n上传（这让我想到了git的推拉） docker push\n\n#### DockerHub上传：\n\n这里要注意 镜像的tag一定要符合要求 如果不符合需要改\n\n通过\n\n```\ndocker tag 镜像id docker账号名/新名:版本号\ndocker tag 9e4e904b2a17 wangchengyang/mytomcat:1.0\n```\n\n![image-20210624144948399](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624144948399.png)\n\n#### 阿里云上传：\n\n##### 1.登录阿里云\n\n##### 2.找到容器镜像服务\n\n##### 3.创建命名空间\n\n![image-20210624145907587](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624145907587.png)\n\n##### 4.创建容器镜像\n\n![image-20210624150020004](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624150020004.png)\n\n##### 5.上传阿里云具体操作方法\n\n###### 1.登录阿里云Docker Registry\n\n```\n$ docker login --username=xxxxx registry.cn-shanghai.aliyuncs.com\n```\n\n用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。\n\n您可以在访问凭证页面修改凭证密码。\n\n###### 2. 从Registry中拉取镜像\n\n```\n$ docker pull registry.cn-shanghai.aliyuncs.com/wangchengyang-study/wangchengyang-test:[镜像版本号]\n```\n\n###### 3. 将镜像推送到Registry\n\n```\n$ docker login --username=xxxxx registry.cn-shanghai.aliyuncs.com$ docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/wangchengyang-study/wangchengyang-test:[镜像版本号]$ docker push registry.cn-shanghai.aliyuncs.com/wangchengyang-study/wangchengyang-test:[镜像版本号]\n```\n\n请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。\n\n###### 4. 选择合适的镜像仓库地址\n\n从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。\n\n如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-shanghai.aliyuncs.com 作为Registry的域名登录。\n\n###### 5. 示例\n\n使用\"docker tag\"命令重命名镜像，并将它通过专有网络地址推送至Registry。\n\n```\n$ docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB$ docker tag 37bb9c63c8b2 registry-vpc.cn-shanghai.aliyuncs.com/acs/agent:0.7-dfb6816\n```\n\n使用 \"docker push\" 命令将该镜像推送至远程。\n\n```\n$ docker push registry-vpc.cn-shanghai.aliyuncs.com/acs/agent:0.7-dfb6816\n```\n\n### 小结\n\n![image-20210624151810382](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624151810382.png)\n\n![image-20210624152143319](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210624152143319.png)\n\n## Docker网络（铺垫 容器编排 集群部署 ）\n\n我去，笔记又没保存就退出了，啊，心态有一点小炸，不过考验自己学习的时候到了！！！！\n\n### 原理\n\n```\nip addr #这个命令用来查看容器ip 后面要用\n```\n\n首先我们 使用 ip addr\n\n![image-20210626124321945](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626124321945.png)\n\n而如果你启动一个容器就会出现变化\n\n![image-20210626124459841](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626124459841.png)\n\n然后进入容器内部查看ip信息\n\n![image-20210626124542737](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626124542737.png)\n\n你会发现这里面的东西是互相对应了，所以说这里就涉及到evth-pair技术\n\nevth-pair就是一对的虚拟设备接口，它们都是成对出现的，一端连着协议，一端彼此相连\n\n正因为这个特性，evth-pair从当了一个桥梁，连接各种虚拟网络\n\n![image-20210626124900837](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626124900837.png)\n\n结论：tomcat01 和tomcat02 都是一个公用的路由器 docker0\n\n所有容器在不指定网络的情况下（后面会讲 -net）都是docker0路由的，它会分配容器一个默认ip\n\n![image-20210626125114823](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626125114823.png)\n\n以上很容易看出这是使用了桥接模式\n\nDocker中的所有网络接口都是虚拟的，虚拟的转发效率高！\n\n只要容器删除，对应网桥一对就没了\n\n### --link\n\n这里思考的问题时能否通过容器名直接访问另一个容器，为什么需要呢？因为可能存在服务名没换但ip换了的情况\n\n不能直接访问但是你可以通过 --link来指定\n\n```\ndocker run -d -P --name tomcat02 --link tomcat01 tomcat\n```\n\n而这里是单向绑定的 为什么？可以通过进入容器查看hosts文件看出\n\n这样绑定后hosts文件中多出一个映射来实现访问\n\n```\ndocker exec -it tomcat02 cat /etc/hosts\n```\n\n![image-20210626131311651](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626131311651.png)\n\ntomcat01 则没有 所以是单向的\n\n但是后面是不建议使用 --link的 可能过时 或者是不满足需求吧\n\n后来我们更多的是选择自定义一个网络\n\ndocker0的问题：他不支持容器名连接访问\n\n\n\n### 自定义网络\n\n容器互联： --link/定义网络\n\n```\ndocker network --help   #这个命令常用\nUsage:  docker network COMMAND\n\nManage networks\n\nCommands:\n  connect     Connect a container to a network\n  create      Create a network\n  disconnect  Disconnect a container from a network\n  inspect     Display detailed information on one or more networks\n  ls          List networks\n  prune       Remove all unused networks\n  rm          Remove one or more networks\n\n```\n\n![image-20210626131724384](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626131724384.png)\n\n#### 网络模式：\n\nbridge：桥接 docker 大桥（默认）\n\nnone：不配置网络\n\nhost：和宿主机共享网络\n\ncontainer：容器网络连通（用的少）\n\n#### 测试\n\n```\n#之前我们直接启动的命令其实是带了默认的参数 --net的 后面我们可以自己指定\ndocker run -d -P --name tomcat01 --net bridge tomcat\n#这里bridge就是docker0\n\n#docker0特点，默认，域名不能访问，--link可以打通连接！\n\n#我们可以自定义个网络\ndocker network create --help\nUsage:  docker network create [OPTIONS] NETWORK\n\nCreate a network\n\nOptions:\n      --attachable           Enable manual container attachment\n      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[])\n      --config-from string   The network from which to copy the configuration\n      --config-only          Create a configuration only network\n  -d, --driver string        Driver to manage the Network (default \"bridge\")\n      --gateway strings      IPv4 or IPv6 Gateway for the master subnet\n      --ingress              Create swarm routing-mesh network\n      --internal             Restrict external access to the network\n      --ip-range strings     Allocate container ip from a sub-range\n      --ipam-driver string   IP Address Management Driver (default \"default\")\n      --ipam-opt map         Set IPAM driver specific options (default map[])\n      --ipv6                 Enable IPv6 networking\n      --label list           Set metadata on a network\n  -o, --opt map              Set driver specific options (default map[])\n      --scope string         Control the network's scope\n      --subnet strings       Subnet in CIDR format that represents a network segment\n\ndocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n```\n\n![image-20210626132731398](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626132731398.png)\n\n这里可以查看网络详细信息\n\n```\ndocker network inspect mynet\n\n\n[\n    {\n        \"Name\": \"mynet\",\n        \"Id\": \"66915e474ee9fe650a70cf37d9eed18551a55e2df11eb52d9a9649b4684c511d\",\n        \"Created\": \"2021-06-26T13:26:59.003948015+08:00\",\n        \"Scope\": \"local\",\n        \"Driver\": \"bridge\",\n        \"EnableIPv6\": false,\n        \"IPAM\": {\n            \"Driver\": \"default\",\n            \"Options\": {},\n            \"Config\": [\n                {\n                    \"Subnet\": \"192.168.0.0/16\",\n                    \"Gateway\": \"192.168.0.1\"\n                }\n            ]\n        },\n        \"Internal\": false,\n        \"Attachable\": false,\n        \"Ingress\": false,\n        \"ConfigFrom\": {\n            \"Network\": \"\"\n        },\n        \"ConfigOnly\": false,\n        \"Containers\": {},\n        \"Options\": {},\n        \"Labels\": {}\n    }\n]\n\n```\n\n![image-20210626133408027](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626133408027.png)\n\n你会发现通过自定义网络去实现的话能够直接通过容器名进行连接访问\n\n通过 docker network inspect mynet也可一看到详情中已经有了两个容器\n\n![image-20210626133809874](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210626133809874.png)\n\n自定义网络中docker已经帮我们维护好了对应关系，推荐使用自定义网络\n\n\n\n### 网络连通\n\n为什么需要？如果说doccker0中的容器想直接访问在自定义网络中的容器那是不现实的。\n\n可以通过一个命令来实现\n\n```\ndocker network connect\n```\n\n![image-20210627091405958](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210627091405958.png)\n\n```\n#测试打通docker0上的tomcat01和mynet上的tomcat-net-01\n\ndocker network connect mynet tomcat01\n\n#本质一个容器 可以有多个ip地址 既存在于docker0网络下又存在于mynet网络下\n```\n\n![image-20210627091950388](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210627091950388.png)\n\n你会发现mynet下多了个容器映射tomcat01\n\n![image-20210627092118015](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/img/image-20210627092118015.png)\n\n总结：如果需要跨网络访问，就需要docker network connect\n\n\n\n### Redis集群部署实战\n\n先创建网卡\n\n```\ndocker network create redis --subnet 172.38.0.0/16\n```\n\n首先这里重点是通过shell脚本来创建启动服务\n\n```\nfor port in $(seq 1 6);\\\ndo \\\nmkdir -p /mydata/redis/node-${port}/conf\ntouch /mydata/redis/node-${port}/conf/redis.conf\ncat <<EOF>/mydata/redis/node-${port}/conf/redis/conf\nport 6379\nbind 0.0.0.0\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1${port}\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes #aof\nEOF   #结束cat命令\ndone\n```\n\n启动容器\n\n```\ndocker run -p 637${port}:6379 -p 1637${port}:13679 --name redis-${port} \\\n-v /mydata/redis/node-${port}/data:/data \\\n-v /mydata/redis/node-${port}/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n```\n\n```\n#通过脚本创建\n[root@izuf66wqqqhhr0ktipcmxfz conf]# for port in $(seq 1 6)\n> \\\n> do\n> docker run -p 637${port}:6379 -p 1637${port}:13679 --name redis-${port} \\\n> -v /mydata/redis/node-${port}/data:/data \\\n> -v /mydata/redis/node-${port}/redis.conf:/etc/redis/redis.conf \\\n> -d --net redis --ip 172.38.0.11 redis:5.0.9-alpine 3.11 redis-server /etc/redis/redis.conf\n> done\n\n\n#或者自己一条一条启动\ndocker run -p 6371:6379 -p 16371:16379 --name redis-1 \\\n-v /mydata/redis/node-1/data:/data \\\n-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\ndocker run -p 6372:6379 -p 16372:16379 --name redis-2 \\\n-v /mydata/redis/node-2/data:/data \\\n-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\ndocker run -p 6373:6379 -p 16373:16379 --name redis-3 \\\n-v /mydata/redis/node-3/data:/data \\\n-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\ndocker run -p 6374:6379 -p 16374:16379 --name redis-4 \\\n-v /mydata/redis/node-4/data:/data \\\n-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\ndocker run -p 6375:6379 -p 16375:16379 --name redis-5 \\\n-v /mydata/redis/node-5/data:/data \\\n-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\ndocker run -p 6376:6379 -p 16376:16379 --name redis-6 \\\n-v /mydata/redis/node-6/data:/data \\\n-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n```\n\n然后通过进入一个redis目录\n\n```\ndocker exec -it redis-1 /bin/sh #这里不是bash了\n```\n\n然后就是通过\n\n```\nredis-cli --cluster create host:port host:port .. --cluster-replicas 1 \n#通过集群模式搭建集群\n```\n\n进入redis集群\n\n```\nredis-cli -c\ncluster nodes #查看节点\n```\n\n\n\n### SpringBoot项目部署\n\n准备个小demo hello的web项目 打包->idea有打包工具\n\n然后就是写Dockerfile可以在IDEA中写 最后都要复制到服务器中\n\n```\nFROM java:8\n\nCOPY *.jar /app.jar\n\nCMD [\"--server.port=8080\"]\n\nEXPOSE 8080\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n\n```\n\n然后就是通过\n\n```\ndocker build -t wcy666\n```\n\n然后启动\n\n```\ndocker run -d -P --name wcy-web wcy666\n```\n\n测试\n\n```\ncurl localhost:xxxx\n```\n\n\n\n\n\n## ","tags":["docker"],"categories":["运维"]},{"title":"java基础知识","url":"/2022/02/21/JAVA基础知识/","content":"\n\n# JAVA基础知识\n\n## 容器/集合\n\n### HashMap\n\n![捕获](https://gitee.com/buxiaoxin2333/pic-bed/raw/master/202202151615866.PNG)\n\n聊到HashMap，我需要想到HashMao的那张结构图 最早的HashMap是数组加链表的形式存在的。\n\n（散列）-> 将任意长度的输入转化为固定长度的输出\n\n链表存在着查询差，但插入简单的特点，所以前面几个版本是由segment（桶）这个概念的，不过现在都是在达到临界点后将链表转化为红黑树。（链表长度达到8或者是数组长度大于64时）\n\n基本的几个值\n\n```\n\t/**\n     * The default initial capacity - MUST be a power of two.\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n    /**\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    /**\n     * The load factor used when none specified in constructor.\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n    /**\n     * The bin count threshold for using a tree rather than list for a\n     * bin.  Bins are converted to trees when adding an element to a\n     * bin with at least this many nodes. The value must be greater\n     * than 2 and should be at least 8 to mesh with assumptions in\n     * tree removal about conversion back to plain bins upon\n     * shrinkage.\n     */\n    static final int TREEIFY_THRESHOLD = 8;\n\n    /**\n     * The bin count threshold for untreeifying a (split) bin during a\n     * resize operation. Should be less than TREEIFY_THRESHOLD, and at\n     * most 6 to mesh with shrinkage detection under removal.\n     */\n    static final int UNTREEIFY_THRESHOLD = 6;\n\n    /**\n     * The smallest table capacity for which bins may be treeified.\n     * (Otherwise the table is resized if too many nodes in a bin.)\n     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts\n     * between resizing and treeification thresholds.\n     */\n    static final int MIN_TREEIFY_CAPACITY = 64;\n```\n\n1.DEFAULT_INITIAL_CAPACITY（初始化容量） 1<<4 也就是16\n\n2.MAXIMUM_CAPACITY（最大的容量） = 1 << 30;\n\n3.DEFAULT_LOAD_FACTOR = 0.75f;（负载因子）具体有啥用 源代码中在说，貌似在扩容中有使用到\n\n4.TREEIFY_THRESHOLD（转化为树的临界点） = 8 也就是说在增加数据时，什么时候将list转化为树（也就是之前讲到的链表达到多少长度时会转化为红黑树）\n\n5.UNTREEIFY_THRESHOLD = 6；（这个有点模糊，我看注释的意思是在不是树的时候重新设置容量大小的操作关键 补充：好像是当你移除节点小于6的时候 红黑树要转化为链表）\n\n6.MIN_TREEIFY_CAPACITY = 64 这个就是当数组长度达到64时就会树化。\n\n\n\n好了基本的常量看完了，就是梦开始的地方了！！！\n\n首先既然有链表，那么就会有节点，这里提供了一个静态内部类\n\n```\nstatic class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n```\n\n4个主要的值，计算得到的hash值，key，value以及下一个节点的引用，这就很好地体现了一开始的那个结构\n\n来点有意思的，之前提到过我们是通过散列算法来确定存储的数组下标位置的，这里就是HashMap中的hash计算方式，这个值是先通过hashCode计算出来的值**按位与**他的无符号右移16位来获得\n\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n\n\n然后来点简单的get方法\n\n```\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n    }//这里会去调用getNode方法,是通过key来进行查找\n    \n    \nfinal Node<K,V> getNode(int hash, Object key) {//这里接收的是hash值和key值\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) { //这里一堆条件同时也进行了一些赋值操作，其中头节点first会通过hash找到 tab[n-1 & hash] \n            if (first.hash == hash && // always check first node  \n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;//这里既然找到了头节点，就好办了，先判断头节点的hash值是否相同，然后是比较key，如果都满足就直接返回\n            if ((e = first.next) != null) {//这里是头节点不满足条件，就接着链表往后找\n                if (first instanceof TreeNode) //这里由于后面会有转化为树的情况，所以在这里要判断是不是树\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);//如果是树就走树的查找方法\n                do {//不是树就开始循环遍历链表\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n}\n```\n\n\n\n上面是获取，接下来就是put方法\n\n```\npublic V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n    \n    //Params:\n\t//hash – hash for key\n\t//key – the key\n\t//value – the value to put\n\t//onlyIfAbsent – if true, don't change existing value\n\t//evict – if false, the table is in creation mode.\n\t//Returns:\n\t//previous value, or null if none\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) { //还是先来看看传入的参数，我们传入的也只有key value\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length; //这里还是简单的判断和赋值 这里resize方法很重要，后面会讲到\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);//这里很显然是看数组位置上是否存在头节点，没有就会建一个，将我们传入的直接丢进去\n        else {//这里就是数组位置上已经有一条链表或者树 这个要判断，然后就可以想象这条链表上或树上是否之前存过相同key，有就覆盖，没有就进行尾插\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;//这里先看头节点是否匹配\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;//记录着集合的修改次数，也就每次add或者remove它的值都会加1\n        if (++size > threshold)//这里我的理解是为了保证容器的查询效率，通过对数组扩容的方式来保证数组中各个链表不至于太长，而影响查询，而这个threshold会在第一个初始化resize时设置 当然后面还有树化来保证查询效率 双管齐下\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n\n\n来吧，重头戏，resize方法：其实这里以及之前都有个迷糊点啊 这个threshold临界点可能不是很清楚干嘛的 因为之前有treeify零界点，导致我容易搞混淆\n\n我在看了一些东西后突然想到了这个值可不可能是因为链表虽然不需要担心扩容之类的问题，但是在查询上是需要遍历是效率不高的，所以说为了使链表不至于太长，所以说我们选择数组扩容，而这个关键就是threshold，因为你每添加一个节点进去就会 size+1 所以说当size > threshold时，为了保证搜索效率而进行的扩容。\n\n```\nif (++size > threshold)\n            resize();\n```\n\n\n\n```\n\n    /**\n     * The next size value at which to resize (capacity * load factor).\n     *\n     * @serial\n     */\n    // (The javadoc description is true upon serialization.\n    // Additionally, if the table array has not been allocated, this\n    // field holds the initial array capacity, or zero signifying\n    // DEFAULT_INITIAL_CAPACITY.)\n    int threshold;//这里说的是重新设置容量后的大小，等下带入下面看看吧.....\n```\n\n\n\n```\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;//首先赋值将需要resize的数组放进来，这里可以看出需要扩容的是数组（一看就知道，啰嗦一句）\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) { //标识不是一个新的HashMap时扩容，就容量和临界值都扩大两倍\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;//这里表示你初始化传入了一个threshold来进行初始化吧，但感觉没啥用\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n            //这里一般就是第一个也就是初始化resize会进入的地方来对cap和thr进行初始化\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);//这个的场景暂时不明确\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n\n\n## 多态\n\n多态是同一个行为具有多个不同表现形式或形态的能力(这个没有同意定义), 关键是分为运行时多态和编译时多态, 运行时多态的体现是在程序运行时确定使用哪一个函数, 比如将子类对象赋值给父类对象, 然后调用某个方法, 而编译时多态是在编译时确定使用哪一个函数, 体现为重载, 在编译时根据参数和返回值类型确定使用哪个函数.","tags":["java"],"categories":["编程"]},{"title":"Linux命令","url":"/2022/02/21/Linux命令/","content":"\n\n\n# Linux命令\n\nuname -r 系统内核版本查看\n\ntar -zxvf 解压命令\n\nwget 下载命令\n\nls -l 查看文件目录 不是1 是L\n\nps -ef|grep redis 查看后台是否启动redis服务\n\nchmod 777 路径/文件 开放读写权限\n\nll 查看当前路径下文件权限\n\ncp 复制备份命令\n\npwd 查看当前路径\n\nlsof -i :端口号 查看端口是否占用\n\nrm -f 文件 删除文件\n\ntouch 文件 创建文件\n\nvim 文件  使用vim文本编辑器\n\nwhereis xxx查看是否有\n\n./文件 表示执行这个文件 例如：./configure\n\ndu -sh 查看当前文件夹大小\n\ndu -h 查看当前文件夹下所有文件 是所有具体的文件"},{"title":"测试一下我的内容","url":"/2022/02/14/hello-world/","content":"---\n\n# 并发\n\n## 特性\n\n原子性\n\n可见性\n\n有序性\n\n## 记录\n\n今天我看到了贴吧中一个贴子，是关于可见性的问题，我看了一下很有意思，自己一开始也不知道为什么\n\n```\npublic class visibilityTest {\n\t//没有加volatile\n    public static Integer flag = 2;\n    public static void main(String[] args) {\n\n        new Thread(()->{\n            System.out.println(\"1号线程启动，执行循环\");\n            while(flag == 2){\n                System.out.println(\"1\");\n            }\n            System.out.println(\"循环结束\");\n        }).start();\n\n        try{\n            Thread.sleep(1000);\n        }catch(InterruptedException e){\n           e.printStackTrace();\n        }\n\n        new Thread(()->{\n            System.out.println(\"二号线程启动\");\n            flag = 3;\n        }).start();\n\n    }\n\n}\n```\n\n以上代码运行你会发现，循环结束了。。。这里问题就在与明明没有保证可见性的东西，为什么线程2修改了变量，线程1很快就获取到了。\n\n这里需要讲到每个线程都有自己的一块工作内存 而实际数据是在主存中，而最后我们会把工作内存的数据更新到主存中。\n\n这里线程2更新数据并保存到了主存，线程1咋知道的。这里一开始我也不清楚，因为一听到可见性就像到volatile，可这也没有啊。\n\n但是通过我的一顿百度，我想我大概是了解了部分真相。\n\n原来 在println中有个操作\n\n```\npublic void println(String x) {\n        synchronized (this) {\n            print(x);\n            newLine();\n        }\n    }\n```\n\n这里会有一个同步代码块，也就是说这里会进行加锁操作\n\n一下是复制的一段\n\nJMM关于synchronized的两条规定：\n\n　　1）线程解锁前，必须把共享变量的最新值刷新到主内存中\n\n　　2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值\n\n　　　（注意：加锁与解锁需要是同一把锁）\n\n   通过以上两点，可以看到synchronized能够实现可见性。同时，由于synchronized具有同步锁，所以它也具有原子性\n\n所以说我们在while循环中使用println时，就是在不断清空工作内存中的共享变量的值，然后获取最新值，所以线程2更新后，线程1能够拿到更新后的值"}]